#!/usr/bin/env node
/* eslint-disable dot-location,no-console,no-process-exit,no-unused-vars*/
/**
 * generate actionType.js, schema.js, spec.js from multi spec files.
 * - need models directory before execution
 */
const path = require('path');
const Swagger = require('swagger-client');
const program = require('commander');
const _ = require('lodash');
const { resolvePath, mkdirpPromise, readSpecFilePromise, getPreparedSpecFiles } = require('../src/tools/utils');
const ModelGenerator = require('../src/tools/model_generator');
const TsModelGenerator = require('../src/tools/ts_model_generator');
const SchemaGenerator = require('../src/tools/schema_generator');
const ActionTypesGenerator = require('../src/tools/action_types_generator');
const JsSpecGenerator = require('../src/tools/js_spec_generator');

program
  .option('-c, --config <configPath>', 'config path')
  .arguments('...<files>')
  .parse(process.argv);
const specFiles = program.args;

const userConfig = program.config ? require(resolvePath(program.config)) : {};
const defaultConfig = require(path.join(__dirname, '../config/parser-config-default.js'));
const config = _.merge({}, defaultConfig, userConfig);
console.info(`parse file: ${specFiles}`);

if (_.isEmpty(specFiles)) {
  console.error('need spec files');
  process.exit(1);
}

console.log(`
  output:
    actionTypes: ${config.outputPath.actions}
    schemas    : ${config.outputPath.schemas}
    js-spec    : ${config.outputPath.jsSpec}
`);

const { filesPath, definitions} = getPreparedSpecFiles(specFiles);

Promise.all(filesPath.map((file) => readSpecFilePromise(file, {dereference: true}))).then((schemas) => {
  const spec = _.merge(...schemas);

  let actionTypesGenerator, modelGenerator, schemaGenerator, tsModelGenerator;
  const [actionsDir, schemasDir, specDir] = ['actions', 'schemas', 'jsSpec'].map((key) => path.dirname(config.outputPath[key]));
  const modelsDir = config.modelsDir || 'dist';
  const baseModelsDir = `${modelsDir}/base`;
  const prepareDirs = [actionsDir, schemasDir, specDir, modelsDir, baseModelsDir].map((p) => mkdirpPromise(p));

  return Swagger({spec}).then(({spec}) => {
    return Promise.all(prepareDirs).then(() => {
      const isV2 = spec.swagger === '2.0';
      const attributeConverter = config.attributeConverter ? config.attributeConverter : str => str;

      modelGenerator =
        config.useTypeScript
          ? new TsModelGenerator({
            outputDir: modelsDir,
            outputBaseDir: baseModelsDir,
            templatePath: config.templates,
            useTypeScript: config.useTypeScript,
            isV2, attributeConverter,
            definitions,
          })
          : new ModelGenerator({
            outputDir: modelsDir,
            outputBaseDir: baseModelsDir,
            templatePath: config.templates,
            usePropType: config.usePropType,
            useFlow: config.useFlow,
            isV2, attributeConverter,
            definitions,
          });

      actionTypesGenerator = new ActionTypesGenerator({
        outputPath: config.outputPath.actions,
        templatePath: config.templates,
        schemasFilePath: config.outputPath.schemas,
        useTypeScript: config.useTypeScript,
      });
      schemaGenerator = new SchemaGenerator({
        outputPath: config.outputPath.schemas,
        templatePath: config.templates,
        modelsDir, modelGenerator, tsModelGenerator, isV2, attributeConverter,
        useTypeScript: config.useTypeScript,
      });
      walkResponses(spec.paths, [schemaGenerator.parse, actionTypesGenerator.appendId]);
      return Promise.all([schemaGenerator, actionTypesGenerator].map((g) => g.write()));
    });
  }).catch((e) => {
    console.error(`Failed: ${e}`);
    process.exit(1);
  });
}).then(() => {
  // no need dereference for js spec file
  return Promise.all(specFiles.map((file) => readSpecFilePromise(file, { dereference: false }))).then((schemas) => {
    const spec = _.merge(...schemas);
    return (new JsSpecGenerator({
      templatePath: config.templates,
      outputPath: config.outputPath.jsSpec,
    })).write(spec);
  });
}).catch((e) => {
  console.error(`Failed: ${e}`);
  process.exit(1);
});

function opId(operation, path, method) {
  return Swagger.helpers.opId(operation, path, method);
}

function walkResponses(paths, onResponses = []) {
  _.each(paths, (operations, path) => {
    _.each(operations, (operation, method) => {
      if (!['GET', 'POST', 'PUT', 'PATCH', 'DELETE'].includes(method.toUpperCase())) {
        // use only RESTful methods
        return;
      }
      if (!_.isObject(operation)) {
        console.warn(`not processed. path:${path}, method:${method}`);
        return;
      }
      if (operation.operationId) {
        console.info(`no use specified operationId. path:${path}, method:${method}, operationId:${operation.operationId}`);
        delete operation.operationId;
      }
      const response = operation.responses;
      const id = opId(operation, path, method);
      onResponses.forEach((onResponse) => onResponse(id, response, {path, method, operation}));
    });
  });
}
