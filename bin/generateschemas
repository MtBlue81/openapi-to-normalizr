#!/usr/bin/env node
/**
 * generate actionType.js, schema.js, spec.js from multi spec files.
 * - need models directory before execution
 */
const path = require('path');
const Swagger = require('swagger-client');
const program = require('commander');
const _ = require('lodash');
const { resolvePath, mkdirpPromise, readSpecFile, isModelDefinition } = require('../src/tools/utils');
const ModelGenerator = require('../src/tools/model_generator');
const SchemaGenerator = require('../src/tools/schema_generator');
const ActionTypesGenerator = require('../src/tools/action_types_generator');
const JsSpecGenerator = require('../src/tools/js_spec_generator');

program
  .option('-c, --config <configPath>', 'config path')
  .arguments('...<files>')
  .parse(process.argv);
const specFiles = program.args;

const userConfig = program.config ? require(resolvePath(program.config)) : {};
const defaultConfig = require(path.join(__dirname, '../config/parser-config-default.js'));
const config = Object.assign({}, defaultConfig, userConfig);
console.info(`parse file: ${specFiles}`);

if (_.isEmpty(specFiles)) {
  console.error('need spec files');
  process.exit(1);
}

const spec = specFiles.reduce((acc, file) => {
  return _.merge(acc, readSpecFile(file));
}, {});

const outputDir = config.outputDir || 'dist';
const [actionsDir, schemasDir] = ['actions', 'schemas'].map((dir) => resolvePath(path.join(outputDir, dir)));
const prepareDirs = [actionsDir, schemasDir].map((path) => mkdirpPromise(path));
let modelGenerator, schemaGenerator, actionTypesGenerator;

const rawSpec = _.cloneDeep(spec);

Swagger({spec}).then(({spec}) => {
  return Promise.all(prepareDirs).then(() => {
    const isV2 = spec.swagger === '2.0';
    const models = isV2 ? spec.definitions : spec.components.schemas;
    (new JsSpecGenerator({outputDir, templatePath: config.templates, specName: 'spec.yml'})).write(rawSpec);

    const modelNameList = [];
    const attributeConverter = config.attributeConverter ? config.attributeConverter : str => str;
    modelGenerator = new ModelGenerator({
      templatePath: config.templates,
      usePropType: config.usePropType,
      useFlow: config.useFlow,
      isV2, attributeConverter,
    });
    const onModel = (model, name) => {
      if (isModelDefinition(model, name) && !modelNameList.includes(name)) {
        modelNameList.push(name);
      }
    };
    walkModels(models, [onModel]);

    actionTypesGenerator = new ActionTypesGenerator({
      outputDir: actionsDir,
      templatePath: config.templates,
      schemasDir,
    });
    schemaGenerator = new SchemaGenerator({
      outputDir: schemasDir,
      templatePath: config.templates,
      modelsDir: config.modelsDir, modelNameList, isV2, attributeConverter,
    });
    walkResponses(spec.paths, [schemaGenerator.parse, actionTypesGenerator.appendId]);
    schemaGenerator.write();
    actionTypesGenerator.write();
  });
}).catch((e) => console.error(`Failed: ${e}`));

function walkModels(models, onModels = []) {
  return _.each(models, (model, name) => {
    onModels.forEach((onModel) => onModel(model, name));
  });
}

function opId(operation, path, method) {
  return Swagger.helpers.opId(operation, path, method);
}

function walkResponses(paths, onResponses = []) {
  _.each(paths, (operations, path) => {
    _.each(operations, (operation, method) => {
      if (!['GET', 'POST', 'PUT', 'DELETE'].includes(method.toUpperCase())) {
        return;
      }
      if (!_.isObject(operation)) {
        console.warn(`not processed. path:${path}, method:${method}`);
        return;
      }
      if (operation.operationId) {
        console.info(`no use specified operationId. path:${path}, method:${method}, operationId:${operation.operationId}`);
        delete operation.operationId;
      }
      const response = operation.responses;
      const id = opId(operation, path, method);
      onResponses.forEach((onResponse) => onResponse(id, response, {path, method, operation}));
    });
  });
}
