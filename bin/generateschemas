#!/usr/bin/env node
/* eslint-disable dot-location,no-console,no-process-exit,no-unused-vars*/
/**
 * generate actionType.js, schema.js, spec.js from multi spec files.
 * - need models directory before execution
 */
const path = require('path');
const Swagger = require('swagger-client');
const program = require('commander');
const isEmpty = require('lodash.isempty');
const merge = require('lodash.merge');
const each = require('lodash.foreach');
const cloneDeep = require('lodash.clonedeep');
const isObject = require('lodash.isobject');
const { resolvePath, mkdirpPromise, readSpecFile, isModelDefinition } = require('../src/tools/utils');
const ModelGenerator = require('../src/tools/model_generator');
const SchemaGenerator = require('../src/tools/schema_generator');
const ActionTypesGenerator = require('../src/tools/action_types_generator');
const JsSpecGenerator = require('../src/tools/js_spec_generator');

program
  .option('-c, --config <configPath>', 'config path')
  .arguments('...<files>')
  .parse(process.argv);
const specFiles = program.args;

const userConfig = program.config ? require(resolvePath(program.config)) : {};
const defaultConfig = require(path.join(__dirname, '../config/parser-config-default.js'));
const config = Object.assign({}, defaultConfig, userConfig);
console.info(`parse file: ${specFiles}`);

if (isEmpty(specFiles)) {
  console.error('need spec files');
  process.exit(1);
}

console.log(`
  output:
    actionTypes: ${config.outputPath.actions}
    schemas    : ${config.outputPath.schemas}
    js-spec    : ${config.outputPath.jsSpec}
`);

const spec = specFiles.reduce((acc, file) => {
  return merge(acc, readSpecFile(file));
}, {});

let actionTypesGenerator, modelGenerator, schemaGenerator;
const [actionsDir, schemasDir, specDir] = ['actions', 'schemas', 'jsSpec'].map((key) => path.dirname(config.outputPath[key]));
const prepareDirs = [actionsDir, schemasDir, specDir].map((p) => mkdirpPromise(p));

const rawSpec = cloneDeep(spec);

Swagger({spec}).then(({spec}) => {
  return Promise.all(prepareDirs).then(() => {
    const isV2 = spec.swagger === '2.0';
    const models = isV2 ? spec.definitions : spec.components.schemas;
    const writePromises = [];
    writePromises.push((new JsSpecGenerator({
      templatePath: config.templates,
      outputPath: config.outputPath.jsSpec,
    })).write(rawSpec));

    const modelNameList = [];
    const attributeConverter = config.attributeConverter ? config.attributeConverter : str => str;
    modelGenerator = new ModelGenerator({
      templatePath: config.templates,
      usePropType: config.usePropType,
      useFlow: config.useFlow,
      isV2, attributeConverter,
    });
    const onModel = (model, name) => {
      if (isModelDefinition(model, name) && !modelNameList.includes(name)) {
        modelNameList.push(name);
      }
    };
    walkModels(models, [onModel]);

    actionTypesGenerator = new ActionTypesGenerator({
      outputPath: config.outputPath.actions,
      templatePath: config.templates,
      schemasFilePath: config.outputPath.schemas,
    });
    schemaGenerator = new SchemaGenerator({
      outputPath: config.outputPath.schemas,
      templatePath: config.templates,
      modelsDir: config.modelsDir, modelNameList, isV2, attributeConverter,
    });
    walkResponses(spec.paths, [schemaGenerator.parse, actionTypesGenerator.appendId]);
    writePromises.push(schemaGenerator.write());
    writePromises.push(actionTypesGenerator.write());
    return writePromises;
  });
}).catch((e) => console.error(`Failed: ${e}`));

function walkModels(models, onModels = []) {
  return each(models, (model, name) => {
    onModels.forEach((onModel) => onModel(model, name));
  });
}

function opId(operation, path, method) {
  return Swagger.helpers.opId(operation, path, method);
}

function walkResponses(paths, onResponses = []) {
  each(paths, (operations, path) => {
    each(operations, (operation, method) => {
      if (!['GET', 'POST', 'PUT', 'DELETE'].includes(method.toUpperCase())) {
        return;
      }
      if (!isObject(operation)) {
        console.warn(`not processed. path:${path}, method:${method}`);
        return;
      }
      if (operation.operationId) {
        console.info(`no use specified operationId. path:${path}, method:${method}, operationId:${operation.operationId}`);
        delete operation.operationId;
      }
      const response = operation.responses;
      const id = opId(operation, path, method);
      onResponses.forEach((onResponse) => onResponse(id, response, {path, method, operation}));
    });
  });
}
